"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.server = exports.connection = void 0;
const node_1 = require("@volar/language-server/node");
const language_core_1 = require("@vue/language-core");
const language_service_1 = require("@vue/language-service");
const protocol_1 = require("./lib/protocol");
const tsPluginClient = require("@vue/typescript-plugin/lib/client");
const utils_1 = require("@vue/typescript-plugin/lib/utils");
const protocol_2 = require("./lib/protocol");
exports.connection = (0, node_1.createConnection)();
exports.server = (0, node_1.createServer)(exports.connection);
const envToVueOptions = new WeakMap();
let tsdk;
let getTsPluginClient;
exports.connection.listen();
exports.connection.onInitialize(async (params) => {
    const options = params.initializationOptions;
    const hybridMode = options.vue?.hybridMode ?? true;
    tsdk = (0, node_1.loadTsdkByPath)(options.typescript.tsdk, params.locale);
    const vueFileExtensions = ['vue'];
    if (options.vue?.additionalExtensions) {
        for (const additionalExtension of options.vue.additionalExtensions) {
            vueFileExtensions.push(additionalExtension);
        }
    }
    if (hybridMode) {
        getTsPluginClient = () => tsPluginClient;
    }
    else {
        getTsPluginClient = (0, language_service_1.createDefaultGetTsPluginClient)(tsdk.typescript, env => envToVueOptions.get(env));
    }
    const result = await exports.server.initialize(params, hybridMode
        ? (0, node_1.createSimpleProjectProviderFactory)()
        : (0, node_1.createTypeScriptProjectProviderFactory)(tsdk.typescript, tsdk.diagnosticMessages), {
        watchFileExtensions: ['js', 'cjs', 'mjs', 'ts', 'cts', 'mts', 'jsx', 'tsx', 'json', ...vueFileExtensions],
        getServicePlugins() {
            return (0, language_service_1.createVueServicePlugins)(tsdk.typescript, env => envToVueOptions.get(env), getTsPluginClient, hybridMode);
        },
        async getLanguagePlugins(serviceEnv, projectContext) {
            const commandLine = await parseCommandLine();
            const vueOptions = commandLine?.vueOptions ?? (0, language_core_1.resolveVueCompilerOptions)({});
            for (const ext of vueFileExtensions) {
                if (vueOptions.extensions.includes(`.${ext}`)) {
                    vueOptions.extensions.push(`.${ext}`);
                }
            }
            const vueLanguagePlugin = (0, language_core_1.createVueLanguagePlugin)(tsdk.typescript, serviceEnv.typescript.uriToFileName, fileName => {
                if (projectContext.typescript?.sys.useCaseSensitiveFileNames ?? false) {
                    return projectContext.typescript?.host.getScriptFileNames().includes(fileName) ?? false;
                }
                else {
                    const lowerFileName = fileName.toLowerCase();
                    for (const rootFile of projectContext.typescript?.host.getScriptFileNames() ?? []) {
                        if (rootFile.toLowerCase() === lowerFileName) {
                            return true;
                        }
                    }
                    return false;
                }
            }, commandLine?.options ?? {}, vueOptions, options.codegenStack);
            envToVueOptions.set(serviceEnv, vueOptions);
            return [vueLanguagePlugin];
            async function parseCommandLine() {
                let commandLine;
                if (projectContext.typescript) {
                    const { sys } = projectContext.typescript;
                    let sysVersion;
                    let newSysVersion = await sys.sync();
                    while (sysVersion !== newSysVersion) {
                        sysVersion = newSysVersion;
                        if (projectContext.typescript.configFileName) {
                            commandLine = (0, language_core_1.createParsedCommandLine)(tsdk.typescript, sys, projectContext.typescript.configFileName);
                        }
                        newSysVersion = await sys.sync();
                    }
                }
                return commandLine;
            }
        },
    });
    if (hybridMode) {
        // handle by tsserver + @vue/typescript-plugin
        result.capabilities.semanticTokensProvider = undefined;
    }
    return result;
});
exports.connection.onInitialized(() => {
    exports.server.initialized();
});
exports.connection.onShutdown(() => {
    exports.server.shutdown();
});
exports.connection.onRequest(protocol_1.ParseSFCRequest.type, params => {
    return (0, language_core_1.parse)(params);
});
exports.connection.onRequest(protocol_1.DetectNameCasingRequest.type, async (params) => {
    const languageService = await getService(params.textDocument.uri);
    if (languageService) {
        return await (0, language_service_1.detect)(languageService.context, params.textDocument.uri, getTsPluginClient(languageService.context));
    }
});
exports.connection.onRequest(protocol_1.GetConvertTagCasingEditsRequest.type, async (params) => {
    const languageService = await getService(params.textDocument.uri);
    if (languageService) {
        return await (0, language_service_1.convertTagName)(languageService.context, params.textDocument.uri, params.casing, getTsPluginClient(languageService.context));
    }
});
exports.connection.onRequest(protocol_1.GetConvertAttrCasingEditsRequest.type, async (params) => {
    const languageService = await getService(params.textDocument.uri);
    if (languageService) {
        return await (0, language_service_1.convertAttrName)(languageService.context, params.textDocument.uri, params.casing, getTsPluginClient(languageService.context));
    }
});
exports.connection.onRequest(protocol_2.GetConnectedNamedPipeServerRequest.type, async (fileName) => {
    const server = await (0, utils_1.searchNamedPipeServerForFile)(fileName);
    if (server) {
        return server;
    }
});
async function getService(uri) {
    return (await exports.server.projects.getProject(uri)).getLanguageService();
}
//# sourceMappingURL=node.js.map