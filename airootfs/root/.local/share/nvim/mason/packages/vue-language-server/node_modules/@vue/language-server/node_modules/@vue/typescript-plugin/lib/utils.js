"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendRequestWorker = exports.searchNamedPipeServerForFile = exports.connect = exports.updatePipeTable = exports.readPipeTable = void 0;
const os = require("os");
const net = require("net");
const path = require("path");
const fs = require("fs");
const { version } = require('../package.json');
const pipeTableFile = path.join(os.tmpdir(), `vue-tsp-table-${version}.json`);
function readPipeTable() {
    if (!fs.existsSync(pipeTableFile)) {
        return [];
    }
    try {
        const servers = JSON.parse(fs.readFileSync(pipeTableFile, 'utf8'));
        return servers;
    }
    catch {
        fs.unlinkSync(pipeTableFile);
        return [];
    }
}
exports.readPipeTable = readPipeTable;
function updatePipeTable(servers) {
    if (servers.length === 0) {
        fs.unlinkSync(pipeTableFile);
    }
    else {
        fs.writeFileSync(pipeTableFile, JSON.stringify(servers, undefined, 2));
    }
}
exports.updatePipeTable = updatePipeTable;
function connect(path) {
    return new Promise(resolve => {
        const client = net.connect(path);
        client.on('connect', () => {
            resolve(client);
        });
        client.on('error', () => {
            return resolve(undefined);
        });
    });
}
exports.connect = connect;
async function searchNamedPipeServerForFile(fileName) {
    const servers = readPipeTable();
    const configuredServers = servers
        .filter(item => item.serverKind === 1);
    const inferredServers = servers
        .filter(item => item.serverKind === 0)
        .sort((a, b) => b.currentDirectory.length - a.currentDirectory.length);
    for (const server of configuredServers) {
        const client = await connect(server.path);
        if (client) {
            const response = await sendRequestWorker({ type: 'containsFile', args: [fileName] }, client);
            if (response) {
                return server;
            }
        }
    }
    for (const server of inferredServers) {
        if (!path.relative(server.currentDirectory, fileName).startsWith('..')) {
            const client = await connect(server.path);
            if (client) {
                return server;
            }
        }
    }
}
exports.searchNamedPipeServerForFile = searchNamedPipeServerForFile;
function sendRequestWorker(request, client) {
    return new Promise(resolve => {
        let dataChunks = [];
        client.on('data', chunk => {
            dataChunks.push(chunk);
        });
        client.on('end', () => {
            if (!dataChunks.length) {
                console.warn('[Vue Named Pipe Client] No response from server for request:', request.type);
                resolve(undefined);
                return;
            }
            const data = Buffer.concat(dataChunks);
            const text = data.toString();
            let json = null;
            try {
                json = JSON.parse(text);
            }
            catch (e) {
                console.error('[Vue Named Pipe Client] Failed to parse response:', text);
                resolve(undefined);
                return;
            }
            resolve(json);
        });
        client.write(JSON.stringify(request));
    });
}
exports.sendRequestWorker = sendRequestWorker;
//# sourceMappingURL=utils.js.map