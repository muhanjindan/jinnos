"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComponentSpans = exports.decorateLanguageServiceForVue = void 0;
const vue = require("@vue/language-core");
const shared_1 = require("@vue/shared");
const componentInfos_1 = require("./requests/componentInfos");
function decorateLanguageServiceForVue(files, languageService, vueOptions, ts, isTsPlugin) {
    const { getCompletionsAtPosition, getCompletionEntryDetails, getCodeFixesAtPosition, getEncodedSemanticClassifications, } = languageService;
    languageService.getCompletionsAtPosition = (fileName, position, options) => {
        const result = getCompletionsAtPosition(fileName, position, options);
        if (result) {
            // filter __VLS_
            result.entries = result.entries.filter(entry => entry.name.indexOf('__VLS_') === -1
                && (!entry.labelDetails?.description || entry.labelDetails.description.indexOf('__VLS_') === -1));
            // modify label
            for (const item of result.entries) {
                if (item.source) {
                    const originalName = item.name;
                    for (const ext of vueOptions.extensions) {
                        const suffix = (0, shared_1.capitalize)(ext.substring('.'.length)); // .vue -> Vue
                        if (item.source.endsWith(ext) && item.name.endsWith(suffix)) {
                            item.name = (0, shared_1.capitalize)(item.name.slice(0, -suffix.length));
                            if (item.insertText) {
                                // #2286
                                item.insertText = item.insertText.replace(`${suffix}$1`, '$1');
                            }
                            if (item.data) {
                                // @ts-expect-error
                                item.data.__isComponentAutoImport = {
                                    ext,
                                    suffix,
                                    originalName,
                                    newName: item.insertText,
                                };
                            }
                            break;
                        }
                    }
                }
            }
        }
        return result;
    };
    languageService.getCompletionEntryDetails = (...args) => {
        const details = getCompletionEntryDetails(...args);
        // modify import statement
        // @ts-expect-error
        if (args[6]?.__isComponentAutoImport) {
            // @ts-expect-error
            const { ext, suffix, originalName, newName } = args[6]?.__isComponentAutoImport;
            for (const codeAction of details?.codeActions ?? []) {
                for (const change of codeAction.changes) {
                    for (const textChange of change.textChanges) {
                        textChange.newText = textChange.newText.replace('import ' + originalName + ' from ', 'import ' + newName + ' from ');
                    }
                }
            }
        }
        return details;
    };
    languageService.getCodeFixesAtPosition = (...args) => {
        let result = getCodeFixesAtPosition(...args);
        // filter __VLS_
        result = result.filter(entry => entry.description.indexOf('__VLS_') === -1);
        return result;
    };
    if (isTsPlugin) {
        languageService.getEncodedSemanticClassifications = (fileName, span, format) => {
            const result = getEncodedSemanticClassifications(fileName, span, format);
            const file = files.get(fileName);
            if (file?.generated?.code instanceof vue.VueGeneratedCode) {
                const { template } = file.generated.code.sfc;
                if (template) {
                    for (const componentSpan of getComponentSpans.call({ typescript: ts, languageService, vueOptions }, file.generated.code, template, {
                        start: span.start - template.startTagEnd,
                        length: span.length,
                    })) {
                        result.spans.push(componentSpan.start + template.startTagEnd, componentSpan.length, 256);
                    }
                }
            }
            return result;
        };
    }
}
exports.decorateLanguageServiceForVue = decorateLanguageServiceForVue;
function getComponentSpans(vueCode, template, spanTemplateRange) {
    const { typescript: ts, languageService, vueOptions } = this;
    const result = [];
    const validComponentNames = (0, componentInfos_1._getComponentNames)(ts, languageService, vueCode, vueOptions);
    const components = new Set([
        ...validComponentNames,
        ...validComponentNames.map(vue.hyphenateTag),
    ]);
    template.ast?.children.forEach(function visit(node) {
        if (node.loc.end.offset <= spanTemplateRange.start || node.loc.start.offset >= (spanTemplateRange.start + spanTemplateRange.length)) {
            return;
        }
        if (node.type === 1) {
            if (components.has(node.tag)) {
                let start = node.loc.start.offset;
                if (template.lang === 'html') {
                    start += '<'.length;
                }
                result.push({
                    start,
                    length: node.tag.length,
                });
                if (template.lang === 'html' && !node.isSelfClosing) {
                    result.push({
                        start: node.loc.start.offset + node.loc.source.lastIndexOf(node.tag),
                        length: node.tag.length,
                    });
                }
            }
            for (const child of node.children) {
                visit(child);
            }
        }
        else if (node.type === 9) {
            for (const branch of node.branches) {
                for (const child of branch.children) {
                    visit(child);
                }
            }
        }
        else if (node.type === 11) {
            for (const child of node.children) {
                visit(child);
            }
        }
    });
    return result;
}
exports.getComponentSpans = getComponentSpans;
//# sourceMappingURL=common.js.map